package com.tseong.learning.text;

public class _05_MySQL {

    /*

    查看MySQL的执行速度
    mySql > show variables like '%pro%';
    mySql > set profiling = 1;
    mySql > select * from xx;
    mySql > show profiles;

    查看执行计划:
    mySql > explain select * from ...

    查看有哪些线程在运行，不仅可以查看当前所有的连接数，还可以查看当前的连接状态帮助识别出有问题的查询语句等
    mysql > show full processlist


    数据库连接池到底应该设置多大:
    下面公式由PostgreSQL提供： 连接数 ＝ （核心数 * 2）+ 有效磁盘数

    常用数据库连接池: C3P0 或 druid

    事务并发带来的问题：
    脏读： 一个事务读取了另一个事务未提交的数据
    不可重复读： 重点是修改。同样条件下两次读取结果不同。也就是说，被读取的数据可以被其它事务修改
    幻读：重点在于新增或删除。同样条件下两次读出来的记录数不一样

    事务的四种隔离级别
    1. Read Uncommitted
    2. Read Committed
    3. Repeatable Read （事务B提交了，只有当事务A也提交了，A才能看到更改的内容，但还是有幻读的问题－A感知不到新插入的数据）
    4. Serializable


    MyBatis:
    一级缓存：作用域：同一个SqlSession中执行相同的SQL语句
    二级缓存：作用域：多个sqlSession共享

    MyBatis延迟加载（默认关）：先查主表需要的信息，里面包含的比如Association，需要用到数据再进行DB查询


    － 存储过程和函数：
    存储过程和函数的区别在于函数必须有返回值，而存储过程没有。存储过程的参数可以使用IN，OUT，INOUT类型，而函数的参数只能是IN类型

    MySQL的优化主要涉及SQL语句及索引的优化，数据表结构的优化，系统配置的优化，硬件的优化
    SQL语句的优化：
    1）优化Insert语句，一次插入多值
    2）应尽量避免在where子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描
    3) 应尽量避免在where子句中对字段进行null值判断。否则引擎将放弃使用索引而进行全表扫描
    4）优化嵌套查询，子查询可以被更有效率的连接（join）替代
    5）很多时候用exists代替是一个好的选择

    其它注意：
    1）使用较小的数据类型解决问题
    2）使用简单的数据类型（Mysql处理int比varchar容易）
    3）尽可能的使用not null定义字段
    4）尽量避免使用text类型。非用不可时最好考虑分表

    唯一索引是什么？
    索引列的值必须唯一，但允许由空值。主键是一种唯一索引，但主键不允许有空值，所以不能说唯一索引就是主键。




    Innodb 的锁机制：
    source: https://www.cnblogs.com/janehoo/p/5603983.html

    Innodb 的锁分两类：lock和latch
        - latch主要是保证并发线程操作临界资源的正确性，要求时间非常短，所以没有死锁检测机制。latch包括mutex（互斥量）和rwlock（读写锁）
        - lock是面向事务，操作（表、页（Innodb没有页锁）、行）等对象，用来管理共享资源的并发访问，是有死锁检测机制的

    行锁：innodb实现了多粒度锁：表锁，行锁。其中行锁包括共享行锁和排他行锁。
    共享行锁（S）：允许事务读取一行数据
    排他行锁（X）：允许事务删除或更新一行数据
    意向锁：数据库需要对细粒度的对象上锁，需要首先给粗粒度的对象上锁。在粗粒度对象上上的锁成为意向锁。innodb的意向锁包括共享意向表锁和排他意向表锁
    共享意向表锁（IS）：S锁对应IS锁
    排他意向表锁（IX）：X锁对应IX锁
    锁兼容：是指在同已对象上允许同种或不同钟锁同时存在

    在给表加行锁前，需要先对改表加意向锁。意向锁是表级别的。各锁之间的兼容情况如下：
            IS      IX      S      X
     IS     兼容    兼容    兼容    不兼容
     IX     兼容    兼容    不兼容  不兼容
     S      兼容    不兼容   兼容   不兼容
     X      不兼容  不兼容   不兼容  不兼容

    意向锁的使用：
    考虑这个例子：
        事务A锁住了表中的一行，让这一行只能读，不能写。
        之后，事务B申请整个表的写锁。
        如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。
        数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。
        数据库要怎么判断这个冲突呢？
            step1：判断表是否已被其他事务用表锁锁表
            step2：判断表中的每一行是否已被行锁锁住。

        注意step2，这样的判断方法效率实在不高，因为需要遍历整个表。
        于是就有了意向锁。

        在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。
        在意向锁存在的情况下，上面的判断可以改成

            step1：不变
            step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。

        注意：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。
     

     */

}
