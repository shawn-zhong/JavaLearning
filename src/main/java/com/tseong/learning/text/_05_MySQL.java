package com.tseong.learning.text;

public class _05_MySQL {

    /*

    查看MySQL的执行速度  (SHOW PROFILLE(S) or SHOW STATUS)
    mySql > show variables like '%pro%';
    mySql > set profiling = 1;
    mySql > select * from xx;
    mySql > show profiles;
    mySql > show profile for query 2 (2是上面结果返回的具体查询id)

    查看执行计划:
    mySql > explain select * from ...

    查看有哪些线程在运行，不仅可以查看当前所有的连接数，还可以查看当前的连接状态帮助识别出有问题的查询语句等
    mysql > show full processlist


    数据库连接池到底应该设置多大:
    下面公式由PostgreSQL提供： 连接数 ＝ （核心数 * 2）+ 有效磁盘数

    常用数据库连接池: C3P0 或 druid

    事务并发带来的问题：
    脏读： 一个事务读取了另一个事务未提交的数据
    不可重复读： 重点是修改。同样条件下两次读取结果不同。也就是说，被读取的数据可以被其它事务修改
    幻读：重点在于新增或删除。同样条件下两次读出来的记录数不一样

    事务的四种隔离级别
    1. Read Uncommitted
    2. Read Committed
    3. Repeatable Read （事务B提交了，只有当事务A也提交了，A才能看到更改的内容，但还是有幻读的问题－A感知不到新插入的数据）
    4. Serializable


    MyBatis:
    一级缓存：作用域：同一个SqlSession中执行相同的SQL语句
    二级缓存：作用域：多个sqlSession共享

    MyBatis延迟加载（默认关）：先查主表需要的信息，里面包含的比如Association，需要用到数据再进行DB查询

    － 存储过程和函数：
    存储过程和函数的区别在于函数必须有返回值，而存储过程没有。存储过程的参数可以使用IN，OUT，INOUT类型，而函数的参数只能是IN类型

    MySQL的优化主要涉及SQL语句及索引的优化，数据表结构的优化，系统配置的优化，硬件的优化
    SQL语句的优化：
    1）优化Insert语句，一次插入多值
    2）应尽量避免在where子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描
    3) 应尽量避免在where子句中对字段进行null值判断。否则引擎将放弃使用索引而进行全表扫描
    4）优化嵌套查询，子查询可以被更有效率的连接（join）替代
    5）很多时候用exists代替是一个好的选择

    其它注意：
    1）使用较小的数据类型解决问题
    2）使用简单的数据类型（Mysql处理int比varchar容易）
    3）尽可能的使用not null定义字段
    4）尽量避免使用text类型。非用不可时最好考虑分表

    唯一索引是什么？
    索引列的值必须唯一，但允许由空值。主键是一种唯一索引，但主键不允许有空值，所以不能说唯一索引就是主键。




    Innodb 的锁机制：
    source: https://www.cnblogs.com/janehoo/p/5603983.html

    Innodb 的锁分两类：lock和latch
        - latch主要是保证并发线程操作临界资源的正确性，要求时间非常短，所以没有死锁检测机制。latch包括mutex（互斥量）和rwlock（读写锁）
        - lock是面向事务，操作（表、页（Innodb没有页锁）、行）等对象，用来管理共享资源的并发访问，是有死锁检测机制的

    行锁：innodb实现了多粒度锁：表锁，行锁。其中行锁包括共享行锁和排他行锁。
    共享行锁（S）：允许事务读取一行数据
    排他行锁（X）：允许事务删除或更新一行数据
    意向锁：数据库需要对细粒度的对象上锁，需要首先给粗粒度的对象上锁。在粗粒度对象上上的锁成为意向锁。innodb的意向锁包括共享意向表锁和排他意向表锁
    共享意向表锁（IS）：S锁对应IS锁
    排他意向表锁（IX）：X锁对应IX锁
    锁兼容：是指在同已对象上允许同种或不同钟锁同时存在

    在给表加行锁前，需要先对改表加意向锁。意向锁是表级别的。各锁之间的兼容情况如下：
            IS      IX      S      X
     IS     兼容    兼容    兼容    不兼容
     IX     兼容    兼容    不兼容  不兼容
     S      兼容    不兼容   兼容   不兼容
     X      不兼容  不兼容   不兼容  不兼容

     （Shawn：X锁和所有的锁都不兼容）

    意向锁的使用：
    考虑这个例子：
        事务A锁住了表中的一行，让这一行只能读，不能写。
        之后，事务B申请整个表的写锁。
        如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。
        数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。
        数据库要怎么判断这个冲突呢？
            step1：判断表是否已被其他事务用表锁锁表
            step2：判断表中的每一行是否已被行锁锁住。

        注意step2，这样的判断方法效率实在不高，因为需要遍历整个表。
        于是就有了意向锁。

        在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。
        在意向锁存在的情况下，上面的判断可以改成

            step1：不变
            step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。

        注意：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。


    －IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突
    －意向锁之间彼此不会冲突，因为它们都只是“有意”，而不是真干，所以是可以兼容的。在加行锁之前，会使用意向锁判断是否冲突；
    －IX和X的关系等同于X和X之间的关系，为什么呢？因为事务获得了IX锁，接下来就有权利获取X锁，这样就会出现两个事务都获取X锁的情况，这和我们已知的X锁和X锁之间互斥是矛盾的




----------------------------

调试MySQL语句：
1. 开启慢查询日志，设置阈值（比如超过3秒就是慢SQL），也可以使用第三方工具分析慢查询日志
2. 使用explain分析慢查询语句。比如SQL语句写得不行，索引没有或者失效，关联查询太多等等
3. 使用 set profiling = 1; show profiles; show profile for query 2 ; 进行分析  （比explain更细节，而且explain只是预估，只支持select？）
4. 使用 show status 辅助分析




explain type的取值：


聚簇索引 和 非聚簇索引的区别

如果一个主键被定义了，那么这个主键就是作为聚集索引
如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引
如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，改列的值会随着数据的插入自增。
(如果InnoBD表没有主键且没有适合的唯一索引（没有构成该唯一索引的所有列都NOT NULL），MySQL将自动创建一个隐藏的名字为“GEN_CLUST_INDEX ”的聚簇索引)

总结：InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，
也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分；

关于聚集索引，非聚集索引，可以看这篇文章比较好：
https://www.cnblogs.com/jiawen010/p/11805241.html


ALL (全表扫描) < index（全索引扫描 (覆盖索引)） < range（索引范围查询） ~ index_merge  < ref （join或最左前缀 并指定值） < eq_ref  < const < system


ALL: 表示全表扫描，这个类型的查询是性能最差的查询之一。通常来说， 我们的查询不应该出现 ALL 类型的查询，因为这样的查询在数据量大的情况下，对数据库的性能是巨大的灾难。
        如一个查询是 ALL 类型查询， 那么一般来说可以对相应的字段添加索引来避免。

index: 表示全索引扫描(full index scan)，和 ALL 类型类似，只不过 ALL 类型是全表扫描，而 index 类型则仅仅扫描所有的索引， 而不扫描数据。index 类型通常出现在：
        所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据。当是这种情况时，Extra 字段 会显示 Using index。（Shawn：实测就是覆盖索引而where不满足复合索引条件）

range: 表示使用索引范围查询，通过索引字段范围获取表中部分数据记录。这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中。
        例如下面的例子就是一个范围查询：explain select * from user_info  where id between 2 and 8；

ref: 此类型通常出现在多表的 join 查询，针对于非唯一或非主键索引，或者是使用了 最左前缀 规则索引的查询。例如下面这个例子中，
        就使用到了 ref 类型的查询：explain select * from user_info, order_info where user_info.id = order_info.user_id AND order_info.user_id = 5

eq_ref: 此类型通常出现在多表的 join 查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果。并且查询的比较操作通常是 =，查询效率较高。例如：explain select * from user_info,
    order_info where user_info.id = order_info.user_id;

const: 针对主键或唯一索引的等值查询扫描，最多只返回一行数据。 const 查询速度非常快， 因为它仅仅读取一次即可。例如下面的这个查询，它使用了主键索引，
    因此 type 就是 const 类型的：explain select * from user_info where id = 2；

system: 表中只有一条数据， 这个类型是特殊的 const 类型。

关于MySQL索引，可以查看这个链接：
https://my.oschina.net/liughDevelop/blog/1788148

     */


}
